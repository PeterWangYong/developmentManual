## 回调

回调的问题有两个：

- 不符合顺序的思考习惯（缺乏顺序性）
- 控制反转，交出了代码控制权（如果交给不信任的第三方工具存在隐患）（缺乏可维护性）



Promise：

- Promise类似第三方返回的一个事件监听器，通过监听Promise的成功和失败进行下面的操作；和单纯回调的区别在于：不再将回调函数本身传递给第三方工具，而是让第三方返回一个信号，然后由自己进行函数调用；所以Promise作为一个中介，将回调函数的控制权又回收到自己手里。
- Promise还实现了关注点分离，第三方工具专注自己的逻辑返回Promise，本地程序监听Promise决定接下来干什么。通过在调用者和回调函数之间增加一个中介Promise，实现了代码的解耦。

```
new Promise(function(resolve, reject) {})
```

- 识别Promise类型就是识别thenable类型，对thenable类型的检测使用“鸭子类型”的类型检测方式，意味着只要具备then方法的对象都可能被误认为是thenable类型

- Promise可以理解为：展示任务状态的信号，根据任务是否完成存在不同状态
- Promise可信任的原因在于Promise.resolve(arg)无论传给arg什么值最终都会得到一个规范化的promise，保证promise.then中的回调得到正确执行。
- 